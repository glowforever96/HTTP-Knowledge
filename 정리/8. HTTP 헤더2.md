## 캐시가 없을 때
* 데이터가 변경되지 않아도 계속 네트워크를 통해서 데이터를 다운로드 받아야함
* 인터넷 네트워크는 매우 느리고 비쌈
* 브라우저 로딩 속도가 느림
* 느린 사용자 경험

## 캐시 적용
* 캐시 덕분에 캐시 가능 시간동안 네트워크를 사용하지 않아도 됨
* 비싼 네트워크 사용량 줄일수 있음
* 브라우저 로딩 속도 빠름
* 빠른 사용자 경험

### 캐시 시간 초과
* 캐시 유효 시간이 초과하면 서버를 통해 데이터를 다시 조회, 캐시를 갱신
* 다시 네트워크 다운로드 발생

* 캐시 유효 시간이 초과해 서버에 다시 요청하면 두 가지 상황이 나타남
1. 서버에서 기존 데이터 변경
2. 기존 데이터 변경 x

**클라이언트의 데이터와 서버의 데이터가 같다는 사실을 확인할 수 있는 방법 필요 -> 검증 헤더 추가**

1. 캐시 유효기간이 초과해도 서버의 데이터가 갱신 되지 않으면
2. 304 Not Modified + 헤더 메타 정보만 응답
3. 클라이언트는 서버가 보낸 응답헤더 정보로 캐시의 메타 정보를 갱신
4. 클라이언트는 캐시에 저장되어 있는 데이터 재활용
5. 결과적으로 용량이 적은 헤더 정보만 다운로드

#### Last-Modified, If-Modified-Since 단점
* 1초 미만단위로 캐시 조정 불가, 날짜 기반 로직 사용
* 데이터를 수정해서 날짜가 다르지만, 같은 데이터를 수정해서 데이터 결과가 똑같은 경우
* 서버에서 별도의 캐시 로직을 관리하고 싶은 경우

### ETag, If-None-Match
* ETag(Entity Tag)
* 캐시용 데이터에 임의의 고유한 버전 이름을 달아둠
  * ex) ETag: 'v1.0'
* 데이터가 변경되면 이 이름을 바꾸어 변경(Hash를 다시 생성)
  * ETag: 'aaaaa' -> 'bbbbb'
* 단순하게 ETag만 보내서 같으면 유지, 다르면 다시 받기

**캐시 제어 로직을 서버에서 완전히 관리**
* 클라이언트는 단순히 이 값을 서버에 제공(클라이언트는 캐시 메커니즘을 모름)

## 캐시 제어 헤더
* Cache-Control: 캐시 제어
* Pragma: 캐시 제어(하위 호환)
* Expires: 캐시 유효 기간(하위 호환)

### Cache-Control
* max-age: 캐시 유효 시간, 초 단위
* no-cache: 데이터는 캐시해도 되지만, 항상 origin 서버에 검증하고 사용
* no-store: 데이터에 민감한 정보가 있으므로 저장하면 안됨

### Pragma - 거의 사용 X

### Expires - 캐시 만료일 지정(하휘 호환)
* 캐시 만료일을 정확한 날짜로 지정
* 지금은 더 유연한 Cache-Control: max-age를 권장

## 프록시 캐시 도입
### Cache-Control (캐시 지시어 -기타)
* public - public 캐시에 저장되어도 됨
* private - 응답이 해당 사용자만을 위한것, private 캐시에 저장해야함
* s-maxage : 캐시에만 적용되는 max-age
* Age: 60 - 오리진 서버에서 응답 후 프록시 캐시 내에 머문 시간

## 캐시 무효화
확실한 캐시 무효화 응답이 있음
* Cache-Control: no-cache, no-store, must-revalidate
* Pragma: no-cache (HTTP 1.0 하위 호환)

### no-cache
* 데이터는 캐시해도 되지만 항상 원 서버에 검증하고 사용

### no-store
* 데이터에 민감한 정보가 있으므로 저장하면 안됨

### must-revalidate
* 캐시 만료후 최초 조회시 원 서버에 검증해야 함
* 원 서버 접근 실패시 반드시 오류가 발생해야함 - 504
* 캐시 유효 시간이라면 캐시를 사용

